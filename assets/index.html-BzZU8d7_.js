import{_ as m,c as i,a as l,e as t,b as a,r as p,o as e}from"./app-CY5as1Zw.js";const r={};function o(c,s){const n=p("ImageCard");return e(),i("div",null,[s[0]||(s[0]=l('<blockquote><p>混淆矩阵（Confusion Matrix）是评估分类模型性能的工具，展示了预测结果与实际结果的对比。它通常用于二分类问题，但也可扩展到多分类。</p></blockquote><h3 id="混淆矩阵的结构" tabindex="-1"><a class="header-anchor" href="#混淆矩阵的结构"><span>混淆矩阵的结构</span></a></h3><p>一个二分类问题的混淆矩阵如下：</p><ul><li>T：代表你是预测成功还是失败</li><li>P/N：代表预测的是正例还是负例</li></ul><table><thead><tr><th></th><th>实际为正例</th><th>实际为负例</th></tr></thead><tbody><tr><td><strong>预测为正例</strong></td><td>TP (真正例)</td><td>FP (假正例)</td></tr><tr><td><strong>预测为负例</strong></td><td>FN (假负例)</td><td>TN (真负例)</td></tr></tbody></table><ul><li><strong>TP (True Positive)</strong>: 实际为正例，预测为正例。</li><li><strong>FP (False Positive)</strong>: 实际为负例，预测为正例。</li><li><strong>FN (False Negative)</strong>: 实际为正例，预测为负例。</li><li><strong>TN (True Negative)</strong>: 实际为负例，预测为负例。</li></ul><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><p>假设有一个二分类模型，用于预测患者是否患有某种疾病。以下是模型的预测结果：</p><ul><li>实际患病人数：100</li><li>实际健康人数：200</li><li>模型预测患病人数：90（其中80人正确预测，10人错误预测）</li><li>模型预测健康人数：210（其中190人正确预测，20人错误预测）</li></ul><p>对应的混淆矩阵如下：</p><table><thead><tr><th></th><th>实际患病</th><th>实际健康</th></tr></thead><tbody><tr><td><strong>预测患病</strong></td><td>80 (TP)</td><td>10 (FP)</td></tr><tr><td><strong>预测健康</strong></td><td>20 (FN)</td><td>190 (TN)</td></tr></tbody></table><h3 id="常用指标" tabindex="-1"><a class="header-anchor" href="#常用指标"><span>常用指标</span></a></h3><p>基于混淆矩阵，可以计算以下指标：</p><ul><li><strong>准确率 (Accuracy)</strong>: (TP + TN) / (TP + FP + FN + TN)</li><li><strong>精确率 (Precision)</strong>: TP / (TP + FP)</li><li><strong>召回率 (Recall)</strong>: TP / (TP + FN)</li><li><strong>F1分数 (F1 Score)</strong>:</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mn>2</mn><mo>⋅</mo><mi>P</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>⋅</mo><mi>R</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>+</mo><mi>R</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\\frac{2 \\cdot Precision \\cdot Recall}{Precision + Recall} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">rec</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">rec</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>精确率: 预测正确的正例的样本数 / 预测的正例的样本数</p><p>召回率: 预测正确的正例的样本数 / 实际的正例的样本数</p></div><h3 id="阈值" tabindex="-1"><a class="header-anchor" href="#阈值"><span>阈值</span></a></h3><blockquote><p>在分类模型中，阈值（Threshold） 是一个用于将模型输出的置信度（或概率）转换为最终分类决策的关键参数。 它决定了模型对某一类别的判定标准。</p></blockquote>',18)),t(n,{image:"https://cdn.jsdelivr.net/gh/Pai3141/PictureBed@main/ml/confusion_matrix-1.png",width:"90%",center:"true"}),s[1]||(s[1]=a("p",null,"分类模型对于每一个样本点都会输出一个置信度。通过设置置信度阈值，就可以完成分类。设置的阈值越低，召回率（Recall）会越高，精确率（Precision）会越小；反之，相反。",-1)),s[2]||(s[2]=a("h3",{id:"pr曲线",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#pr曲线"},[a("span",null,"PR曲线")])],-1)),s[3]||(s[3]=a("blockquote",null,[a("p",null,"PR曲线就是以精确度为纵坐标，以召回率为横坐标绘制出的曲线。")],-1)),t(n,{image:"https://cdn.jsdelivr.net/gh/Pai3141/PictureBed@main/ml/PR-curve.png",width:"50%"}),s[4]||(s[4]=a("h3",{id:"roc曲线",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#roc曲线"},[a("span",null,"ROC曲线")])],-1)),s[5]||(s[5]=a("blockquote",null,[a("p",null,"ROC 曲线（Receiver Operating Characteristic Curve）是一种用于评估分类模型性能的工具，特别是在二分类问题中。 它通过绘制真正率（True Positive Rate, TPR） 和假正率（False Positive Rate, FPR） 的关系来展示模型在不同阈值下的表现。")],-1)),t(n,{image:"https://cdn.jsdelivr.net/gh/Pai3141/PictureBed@main/ml/ROC-curve.png",width:"50%"}),s[6]||(s[6]=l('<ol><li>真正率（TPR，True Positive Rate）</li></ol><ul><li>也称为<strong>召回率（Recall）</strong> 或<strong>灵敏度（Sensitivity）</strong>。</li></ul><p>表示模型正确识别正类样本的能力：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TPR = \\frac{TP}{TP + FN} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">TPR</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">TP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">FN</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">TP</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li><strong>TP（True Positive）</strong>：被正确预测为正类的样本数。</li><li><strong>FN（False Negative）</strong>：被错误预测为负类的正类样本数。</li></ul><ol start="2"><li>假正率（FPR，False Positive Rate）</li></ol><p>表示模型错误地将负类样本预测为正类的比例：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>P</mi><mi>R</mi><mo>=</mo><mfrac><mrow><mi>F</mi><mi>P</mi></mrow><mrow><mi>F</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">FPR = \\frac{FP}{FP + TN} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">FPR</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">FP</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">TN</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">FP</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li><strong>FP（False Positive）</strong>：被错误预测为正类的负类样本数。</li><li><strong>TN（True Negative）</strong>：被正确预测为负类的样本数。</li></ul><ol start="3"><li>阈值的作用</li></ol><ul><li>ROC 曲线通过调整分类模型的阈值，计算不同阈值下的 TPR 和 FPR，并将它们绘制成曲线。</li></ul><h4 id="auc" tabindex="-1"><a class="header-anchor" href="#auc"><span>AUC</span></a></h4><p>AUC 是 ROC 曲线下方的面积，用于量化模型的整体性能。 AUC 的取值范围是 [0, 1]：</p><ul><li>AUC = 1 ：完美分类器。</li><li>AUC = 0.5 ：随机猜测分类器。</li><li>AUC &lt; 0.5 ：模型表现比随机猜测还差（通常说明模型有问题）。</li></ul>',14))])}const d=m(r,[["render",o],["__file","index.html.vue"]]),g=JSON.parse('{"path":"/python/lp5810au/","title":"混淆矩阵","lang":"zh-CN","frontmatter":{"title":"混淆矩阵","createTime":"2025/02/04 20:05:27","permalink":"/python/lp5810au/"},"headers":[],"readingTime":{"minutes":3.1,"words":930},"git":{"updatedTime":1740062596000,"contributors":[{"name":"paiad","username":"paiad","email":"2369538173@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/paiad?v=4","url":"https://github.com/paiad"}]},"filePathRelative":"notes/python/machine-learning/Confusion-Matrix.md"}');export{d as comp,g as data};
